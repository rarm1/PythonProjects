import sys
import traceback

import numpy as np
import pandas as pd
import statsmodels.api as sm

from assets import file_id_reader

global DOCUMENT


# Removes all variables that are NA - important for display and processing
def array_sort():
	"""

	:return:
	"""
	# print(DOCUMENT.iloc[0:20, 3:10])
	performance_dataframe = DOCUMENT.iloc[7:, 3:10].dropna()
	five_year_returns = DOCUMENT.iloc[7:, 10].dropna()
	return performance_dataframe, five_year_returns


def excel_printer(to_write):
	"""
	This accepts an array seperated into the given results.
	:param to_write: Array
	:return: Success
	"""
	filename = "Regression Output.xlsx"
	try:
		with pd.ExcelWriter(filename, engine="openpyxl") as writer:
			pd.DataFrame(to_write[0]).to_excel(writer, index=False, sheet_name="ROA")
			pd.DataFrame(to_write[1]).to_excel(writer, index=False, sheet_name="Cash return")
			pd.DataFrame(to_write[2]).to_excel(writer, index=False, sheet_name="Economic Moat")
			pd.DataFrame(to_write[3]).to_excel(writer, index=False, sheet_name="Debt to Capital")
			pd.DataFrame(to_write[4]).to_excel(writer, index=False, sheet_name="Net margin")
			pd.DataFrame(to_write[5]).to_excel(writer, index=False, sheet_name="ROIC")
			pd.DataFrame(to_write[6]).to_excel(writer, index=False, sheet_name="ROE")
		return True
	except Exception as e:
		print("There has been an error writing to Excel.", e)
		print(traceback.format_exception(*sys.exc_info()))
		return False


# This uses the 'statsmodel.api' library for ease.
def reg_coeff_calc(x, y):
	"""

	:param x:
	:param y:
	:return:
	"""
	# When reading from Excel the default datatype is not compatible with the 'stats' library. This converts it.
	x = x.astype('float64')
	y = y.astype('float64')
	# Reshape -1, 1 transforms a horizontal array into a vertical array.
	# This is important as it is the independant variable.
	x = np.array(x).reshape(-1, 1)
	# Similarly, y enters this function as a pandas dataframe,
	# it must be a numpy array to be used by the 'stats' library.
	# This is due to numpy and stats being written in C, I believe.
	y = np.array(y)
	# This constant is required the independant variable.
	x = sm.add_constant(x)
	results = sm.OLS(y, x).fit()
	# The line below can be commented out to visualise the statistical model that is generated by this function.
	# print(results.smmary())
	return results


# All of these results are accessible from the statsmodel library.
def create_variance_dataframe(results, header):
	"""

	:param results:
	:param header:
	:return:
	"""
	df = pd.DataFrame({
		"Benchmark": header,
		'f_values': results.fvalue,
		'p_values': results.pvalues,
		't_values': results.tvalues,
		'Standard Error': results.bse,
		'Coefficients': results.params
	})
	return df


# This creates arrays that're easier to work with using the 'stats' module.
def benchmark_iterator(input_):
	"""

	:param input_:
	:return:
	"""
	# This sets Y to the returns column, which is passed as a list within a list of lists.
	y = input_[1]
	# The headers are imported from the document.
	# Therefore, the headers should be altered, if the output is to be altered.
	headers = list(input_[0].columns.values)
	to_return = []
	for i in range(input_[0].shape[1]):
		header = headers[i]
		x = input_[0].iloc[:, i]
		# Calculates the regression coefficient between the two columns.
		results = reg_coeff_calc(x, y)
		df = create_variance_dataframe(results, header)
		to_return.append(df)
	return to_return


def main():
	"""

	"""
	global DOCUMENT
	all_files = file_id_reader.list_all_files()
	if len(all_files) == 0:
		sys.exit("Please ensure that there are files ending in .xlsx within the project folder.")
	filename_user = file_id_reader.user_selected_file(all_files)
	filenames = file_id_reader.file_name_generator(filename_user)
	for filename in filenames:
		DOCUMENT = pd.read_excel(filename, header=8)
		important_information = array_sort()
		calculations_completed = benchmark_iterator(important_information)
		if excel_printer(calculations_completed):
			print("File was written successfully.")
		else:
			print("There was an error printing this document.")


if __name__ == '__main__':
	main()
